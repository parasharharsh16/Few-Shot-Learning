# -*- coding: utf-8 -*-
"""Few_Shot_Learning_CosineSimilarity.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JwTDcgeHnAA7k3y6J1W0DLG4N2130vhK

#### **Few Shot Learning**
To put it in simple words, when we need to perform a task for new class which is not used in training is adequlatly hard job and has problem of catastropic forgetting if we retrain the model on new task only.
To overcome this issue, instead of retraining the model on new class, we will compare the features of input image and ground-truth

##### Model To be usedL: VGG

Importing libraries
"""

import torch
import torch.nn as nn
import torchvision.models as models
import torchvision.transforms as transforms
from PIL import Image
from scipy.spatial.distance import cosine
import os
import matplotlib.pyplot as plt
import numpy as np
import torch.nn.functional as F

"""Import pre-trained VGG model"""

vgg = models.vgg16(pretrained=True)

"""Remove the fully connected layers (classifier) to use VGG as a feature extractor"""

feature_extractor = nn.Sequential(*list(vgg.features.children()))

"""Preprocess images"""

preprocess = transforms.Compose([
  transforms.Resize(256),
  transforms.CenterCrop(224),
  transforms.ToTensor(),
  transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

"""Function to extract features from the image"""

def extract_features(image_path, feature_extractor, preprocess):
  image = Image.open(image_path)
  image = preprocess(image)
  # Add batch dimension to the image
  image = image.unsqueeze(0)

  # Pass the image through the feature extractor
  with torch.no_grad():
    features = feature_extractor(image)

  return features.squeeze(0)

"""We will be using Cosine similarity, as similiarity matrics"""

def compute_cosine_similarity(feature1, feature2):
  # Normalize feature vectors
  feature1_norm = F.normalize(feature1, p=2, dim=0)
  feature2_norm = F.normalize(feature2, p=2, dim=0)

  # Compute cosine similarity
  cosine_sim = torch.dot(feature1_norm.view(-1), feature2_norm.view(-1))

  return cosine_sim.item()  # Convert to Python float

"""Compare the different features of ground truth images with input image to give best match"""

def show_image(image_path):
  img = Image.open(image_path)

  # Convert image to numpy array
  img_np = np.array(img)

  # Display the image
  plt.imshow(img_np)
  plt.show()

def get_prediction(input_image_path, ground_truth_folder):
  # Extract features from the input image
  input_features = extract_features(input_image_path, feature_extractor, preprocess)
  show_image(input_image_path)
  # Initialize variables to store best match information
  best_match_image = None
  best_match_similarity = 0.0

  # Iterate over images in the ground truth folder
  for filename in os.listdir(ground_truth_folder):
    if filename.endswith('.jpg'):
      # Construct full path to the ground truth image
      image_path = os.path.join(ground_truth_folder, filename)

      # Extract features from the ground truth image
      gt_features = extract_features(image_path, feature_extractor, preprocess)

      # Compute cosine similarity between input features and ground truth features
      similarity = compute_cosine_similarity(input_features, gt_features)

      # Update best match if current image has smaller distance
      if similarity > best_match_similarity:
        best_match_image = image_path
        best_match_similarity = similarity
  best_match_class = (best_match_image.split('/')[len(best_match_image.split('/'))-1]).replace(".jpg","")
  # Print best match image and distance
  print("Prediected Class:",best_match_class )
  print("Similarity score:", best_match_similarity)

image_path = '/content/inputimg.jpg'
groundtruthfolder = '/content/groundtruth'
get_prediction(image_path, groundtruthfolder )